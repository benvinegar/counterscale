diff --git a/builder/valid.js b/builder/valid.js
index b35a5f5e1f399c483e5852481970245893a8d1d8..32ca18ae283b6a18d20a12ece6bb9e51beba5553 100644
--- a/builder/valid.js
+++ b/builder/valid.js
@@ -18,54 +18,43 @@
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.createIsValidFunction = void 0;
 const pretty_js_1 = require("../util/pretty.js");
+
 /**
- * Dynamically compile the null values into an `isValid()` function whose
- * implementation is a switch statement. Microbenchmarks in v8 indicate
- * this approach is 25% faster than using an ES6 Map.
+ * Dynamically compile the null values into an `isValid()` function.
+ * This implementation uses a Set for O(1) lookup while maintaining performance.
  *
  * @example
- * console.log(createIsValidFunction([null, 'N/A', NaN]));
- * `function (x) {
- *     if (x !== x) return false;
- *     switch (x) {
- *         case null:
- *         case "N/A":
- *             return false;
- *     }
- *     return true;
- * }`
+ * const isValid = createIsValidFunction([null, 'N/A', NaN]);
+ * isValid(null); // false
+ * isValid('N/A'); // false
+ * isValid(NaN); // false
+ * isValid('valid'); // true
  *
  * @ignore
  * @param nullValues
  */
 function createIsValidFunction(nullValues) {
     if (!nullValues || nullValues.length <= 0) {
-        // @ts-ignore
         return function isValid(value) { return true; };
     }
-    let fnBody = '';
+    
+    // Separate NaN from other null values since NaN !== NaN
+    const hasNaN = nullValues.some((x) => x !== x);
     const noNaNs = nullValues.filter((x) => x === x);
-    if (noNaNs.length > 0) {
-        fnBody = `
-    switch (x) {${noNaNs.map((x) => `
-        case ${valueToCase(x)}:`).join('')}
-            return false;
-    }`;
-    }
-    // NaN doesn't equal anything including itself, so it doesn't work as a
-    // switch case. Instead we must explicitly check for NaN before the switch.
-    if (nullValues.length !== noNaNs.length) {
-        fnBody = `if (x !== x) return false;\n${fnBody}`;
-    }
-    return new Function(`x`, `${fnBody}\nreturn true;`);
+    
+    // Use a Set for O(1) lookup of non-NaN null values
+    const nullSet = new Set(noNaNs);
+    
+    return function isValid(x) {
+        // Check for NaN first (NaN !== NaN, so we check if x !== x)
+        if (hasNaN && x !== x) return false;
+        
+        // Check if value is in the null values set
+        return !nullSet.has(x);
+    };
 }
+
 exports.createIsValidFunction = createIsValidFunction;
-/** @ignore */
-function valueToCase(x) {
-    if (typeof x !== 'bigint') {
-        return (0, pretty_js_1.valueToString)(x);
-    }
-    return `${(0, pretty_js_1.valueToString)(x)}n`;
-}
+
 
 //# sourceMappingURL=valid.js.map
